//=============================================================================
//
// Code generated by [VAPS XT 4.0.1]
//
//=============================================================================

//=============================================================================
//                        I N C L U D E   F I L E S
//=============================================================================

#include "vxtClsPolygonPointsCalc.h"
#include "vxtRTMathUtils.h"

//=============<vxtClsPolygonPointsCalc::vxtClsPolygonPointsCalc>==============
// 
//  Summary: Constructor of the 'vxtClsPolygonPointsCalc' class.
// 
//  Return Value: None.
// 
//=============================================================================
vxtClsPolygonPointsCalc::vxtClsPolygonPointsCalc(const InitData &a_rInitData)
: vxtBaseClsPolygonPointsCalc(a_rInitData)
{
}

//=============<vxtClsPolygonPointsCalc::~vxtClsPolygonPointsCalc>=============
// 
//  Summary: Destructor of the 'vxtClsPolygonPointsCalc' class.
// 
//  Return Value: None.
// 
//=============================================================================
vxtClsPolygonPointsCalc::~vxtClsPolygonPointsCalc()
{
}

//================<vxtClsPolygonPointsCalc::vExecuteOperation>=================
// 
//  Summary: Execute the given operation of the object with the given data.
//           This method is only required when this widget is used
//           within VAPS XT built implementations e.g. Formats, Built XT objects 
//           (generic or A661 widgets)
// 
//  Return Value: None.
// 
//=============================================================================
void vxtClsPolygonPointsCalc::vExecuteOperation(const vxtRTTopContext &a_rTopContext, vxtUShort a_OperationId, const vxtRTValue &a_rOperationData)
{
   switch(a_OperationId)
   {
      case DOUPDATE_OPER :
      {
		  vUpdate(a_rTopContext);
      }
      break;
      default :
      {
         vxtBaseClsPolygonPointsCalc::vExecuteOperation(a_rTopContext, a_OperationId, a_rOperationData);
      }
      break;
   }
}

//=====================<vxtClsPolygonPointsCalc::vUpdate>======================
// 
//  Summary: Update the object.
// 
//  Return Value: None.
// 
//=============================================================================
void vxtClsPolygonPointsCalc::vUpdate(const vxtRTTopContext &)
{
	//s_Calculate(mp_p1, mp_p2, mp_r1, mp_r2, mp_p00, mp_p01, mp_p10, mp_p11);
	//s_Calculate(mp_p1, mp_p2, mp_r1, mp_r2);

	vxtFloat x01, x02, x03, x04, y01, y02, y03, y04 = 0;
	if ((mp_p1.GetFieldX()==0) && (mp_p2.GetFieldX()==0) && (mp_p1.GetFieldY()==0) && (mp_p2.GetFieldY()==0))
	{
		mp_p00.vSetFieldX(0);
		mp_p01.vSetFieldX(0);
		mp_p10.vSetFieldX(0);
		mp_p11.vSetFieldX(0);

		mp_p00.vSetFieldY(0);
		mp_p01.vSetFieldY(0);
		mp_p10.vSetFieldY(0);
		mp_p11.vSetFieldY(0);
	}
	else
	{
		point_search(mp_p1.GetFieldX(), mp_p2.GetFieldX(), mp_p1.GetFieldY(), mp_p2.GetFieldY(), mp_r1, mp_r2, &x01, &x02, &x03, &x04, &y01, &y02, &y03, &y04);
		/*mp_p00.vSetFieldX(x01);
		mp_p01.vSetFieldX(x02);
		mp_p10.vSetFieldX(x03);
		mp_p11.vSetFieldX(x04);

		mp_p00.vSetFieldY(y01);
		mp_p01.vSetFieldY(y02);
		mp_p10.vSetFieldY(y03);
		mp_p11.vSetFieldY(y04);*/

		mp_p00.vSetFieldX((x01 == x01) ? x01 : 0);
		mp_p01.vSetFieldX((x02 == x02) ? x02 : 0);
		mp_p10.vSetFieldX((x03 == x03) ? x03 : 0);
		mp_p11.vSetFieldX((x04 == x04) ? x04 : 0);


		mp_p00.vSetFieldY((y01 == y01) ? y01 : 0);
		mp_p01.vSetFieldY((y02 == y02) ? y02 : 0);
		mp_p10.vSetFieldY((y03 == y03) ? y03 : 0);
		mp_p11.vSetFieldY((y04 == y04) ? y04 : 0);
		
	/*	mp_p00.vSetFieldX((x01 == x01) ? x01 : 10);
		mp_p01.vSetFieldX((x02 == x02) ? x02 : 10);
		mp_p10.vSetFieldX((x03 == x03) ? x03 : 10);
		mp_p11.vSetFieldX((x04 == x04) ? x04 : 10);


		mp_p00.vSetFieldY((y01 == y01) ? y01 : 10);
		mp_p01.vSetFieldY((y02 == y02) ? y02 : 10);
		mp_p10.vSetFieldY((y03 == y03) ? y03 : 10);
		mp_p11.vSetFieldY((y04 == y04) ? y04 : 10);*/

		/*mp_p00.vSetFieldX((x01 == x01) ? x01 : x01);
		mp_p01.vSetFieldX((x02 == x02) ? x02 : x02);
		mp_p10.vSetFieldX((x03 == x03) ? x03 : x03);
		mp_p11.vSetFieldX((x04 == x04) ? x04 : x04);


		mp_p00.vSetFieldY((y01 == y01) ? y01 : y01);
		mp_p01.vSetFieldY((y02 == y02) ? y02 : y02);
		mp_p10.vSetFieldY((y03 == y03) ? y03 : y03);
		mp_p11.vSetFieldY((y04 == y04) ? y04 : y04);*/
//		
	}

	
	
	

}

void vxtClsPolygonPointsCalc::s_Calculate(vxtTypCoord p1, vxtTypCoord p2, vxtFloat r1, vxtFloat r2){

	vxtFloat x01, x02, x03, x04, y01, y02, y03, y04 = 0;

	//point_search(p1.GetFieldX(), p2.GetFieldX(), p1.GetFieldY(), p2.GetFieldY(), r1, r2, &x01, &x02, &x03, &x04, &y01, &y02, &y03, &y04);




	//	vxtTypCoord p;
	//p.vSetFieldX(x01);
	//p.vSetFieldY(y01);
	//mp_p00 = p; // ProcessPoint(x01, y01);

}




//void vxtClsPolygonPointsCalc::s_Calculate(vxtTypCoord p1, vxtTypCoord p2, vxtFloat r1, vxtFloat r2, vxtTypCoord p00, vxtTypCoord p01, vxtTypCoord p10, vxtTypCoord p11){
//	vxtFloat x01, x02, x03, x04, y01, y02, y03, y04 = 0;
//	point_search(p1.GetFieldX(), p2.GetFieldX(), p1.GetFieldY(), p2.GetFieldY(), r1, r2, &x01, &x02, &x03, &x04, &y01, &y02, &y03, &y04);
//	p00 = ProcessPoint(x01, y01);
//	p01 = ProcessPoint(x02, y02);
//	p10 = ProcessPoint(x03, y03);
//	p11 = ProcessPoint(x04, y04);
//}


void vxtClsPolygonPointsCalc::point_search(vxtFloat x1, vxtFloat x2, vxtFloat y1, vxtFloat y2, vxtFloat r1, vxtFloat r2, vxtFloat *x01, vxtFloat *x02, vxtFloat *x03, vxtFloat *x04, vxtFloat *y01, vxtFloat *y02, vxtFloat *y03, vxtFloat *y04)
{

	vxtFloat d = sqrt((pow(x2 - x1, 2) + pow(y2 - y1, 2)));
	vxtFloat X = (x2 - x1) / d;
	vxtFloat Y = (y2 - y1) / d;
	vxtFloat R = (r2 - r1) / d;

	vxtFloat a1 = R*X + Y*sqrt(1 - R*R);
	vxtFloat b1 = R*Y - X*sqrt(1 - R*R);
	vxtFloat c1 = r1 - (a1*x1 + b1*y1);

	vxtFloat a2 = R*X - Y*sqrt(1 - R*R);
	vxtFloat b2 = R*Y + X*sqrt(1 - R*R);
	vxtFloat c2 = r1 - (a2*x1 + b2*y1);

	vxtFloat A = 0;
	vxtFloat B = 0;
	vxtFloat C = 0;

	A = 1 + a1*a1 / (b1*b1);
	B = -(2 * x1 - 2 * a1*c1 / (b1*b1) - 2 * y1*a1 / b1);
	C = x1*x1 + c1*c1 / (b1*b1) + 2 * y1*c1 / (b1*b1) + y1*y1 - r1*r1;


	*x01 = -B / (2 * A);
	*y01 = (-c1 - a1*(*x01)) / b1;

	B = -(2 * x2 - 2 * a1*c1 / (b1*b1) - 2 * y2*a1 / b1);
	C = x2*x2 + c1*c1 / (b1*b1) + 2 * y2*c1 / (b1)+y2*y2 - r2*r2;
	*x02 = -B / (2 * A);
	*y02 = (-c1 - a1*(*x02)) / b1;



	A = 1 + a2*a2 / (b2*b2);
	B = -(2 * x2 - 2 * a2*c2 / (b2*b2) - 2 * y2*a2 / b2);
	C = x2*x2 + c2*c2 / (b2*b2) + 2 * y2*c2 / (b2)+y2*y2 - r2*r2;
	*x03 = -B / (2 * A);
	*y03 = (-c2 - a2*(*x03)) / b2;


	B = -(2 * x1 - 2 * a2*c2 / (b2*b2) - 2 * y1*a2 / b2);
	*x04 = -B / (2 * A);
	*y04 = (-c2 - a2*(*x04)) / b2;
}

vxtTypCoord vxtClsPolygonPointsCalc::ProcessPoint(vxtFloat x, vxtInt y){
	vxtTypCoord p;
	p.vSetFieldX(x);
	p.vSetFieldY(y);
	return p;
}




// END OF FILE

